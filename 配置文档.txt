mvn clean package -Dmaven.test.skip=true
1.配置安装jdk
tar -zvxf jdk-8u171-linux-x64.tar.gz
mv jdk1.8.0_171 jdk
mv jdk /data/app
cd /data/app
vim /etc/profile
export JAVA_HOME=/data/app/jdk
export JRE_HOME=/data/app/jdk/jre
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
source /etc/profile
java -version

wget https://releases.hashicorp.com/consul/1.5.3/consul_1.5.3_linux_amd64.zip
wget https://releases.hashicorp.com/consul/1.5.3/consul_1.5.3_web_ui.zip
vim /etc/profile
CONSUL_HOME=/data/app
export CONSUL_HOME
export PATH=${PATH}:${CONSUL__HOME}/consul

consul agent -dev -client 10.0.50.83
consul agent -dev      #以dev模式运行,这种模式启动一个单节点的Consul环境，它不适用于生产环境。该参数配置下，不会有任何持久化操作，即不会有任何数据写入到磁盘

consul agent -server   #以server模式启动

consul agent           #默认是以client模式运行,client非常轻量级，它注册服务、运行healthchecks、转发query到servers。agent必须运行于集群上的每一个节点。

查询端口是否被使用
netstat -anp | grep 端口号

2.运行java包
cd /data/app
java -jar ***.jar

3.配置redis
wget http://download.redis.io/releases/redis-4.0.10.tar.gz
tar -zxvf redis-4.0.10.tar.gz
cd redis-4.0.10
cd /src
make
make test
apt-get install tcl
vim redis.conf
#bind 127.0.0.1
daemonize yes
将protected-mode yes  改成  protected-mode no
配置redis环境变量
vim /etc/profile
export REDIS_HOME=/data/app/redis-4.0.10
export PATH=$PATH:$REDIS_HOME/src
source /etc/profile
redis-server /data/app/redis-4.0.10/redis.conf
redis-cli
127.0.0.1:6379> set name math
OK
127.0.0.1:6379> get name
"math"
127.0.0.1:6379> 

java -jar -XX:+UseG1GC -Xms1g -Xmx1g -Duser.timezone=Asia/Shanghai mobile-app-gateway-8880-web.jar >> /data/logs/8880/spring.log 2>&1
java -jar -XX:+UseG1GC -Xms256m -Xmx256m -Duser.timezone=Asia/Shanghai job-api-8860-web.jar >> /data/logs/8860/spring.log 2>&1

在计划任务中经常可以看到。例如我们公司的计划任务举例：
*/2 * * * * root cd /opt/xxxx/test_S1/html/xxxx/admin; php index.php task testOne >/dev/null 2>&1
*/2 * * * * root cd /opt/xxxx/test_S1/html/xxxx/admin; php index.php task testTwo >/dev/null 2>&1
对于& 1 更准确的说应该是文件描述符 1,而1标识标准输出，stdout。
对于2 ，表示标准错误，stderr。
2>&1 的意思就是将标准错误重定向到标准输出。这里标准输出已经重定向到了 /dev/null。那么标准错误也会输出到/dev/null
可以把/dev/null 可以看作"黑洞". 它等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到.
偶尔也可以把 & 在命令的最后加上，表示让程序后台执行。

nohup java -jar mobile-app-gateway-8880-web.jar > /dev/null 2>&1 &
nohup java -jar job-api-8860-web.jar > /dev/null 2>&1 &
nohup ./data/app/consul agent -dev > /dev/null 2>&1 &
nohup java -jar job-server-8800-web.jar > /dev/null 2>&1 &
nohup java -jar job-write-server-8830-web.jar > /dev/null 2>&1 &

nohup和&的区别
& ： 指在后台运行
nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&才是后台运行
&是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出
那么，我们可以巧妙的吧他们结合起来用就是
nohup COMMAND &
这样就能使命令永久的在后台执行

DockerFile文件的样板
FROM gmaslowski/jdk:latest
LABEL name="job-server" \
      maintainer="liangchao<liangchao@joiway.com>" \
      build-date="`date +%Y%m$d`"
WORKDIR /data/app
COPY job-server-8800-web.jar ./
CMD ["java","-jar","-XX:+UseG1GC","-Xms1000m","-Xmx1000m","-Duser.timezone=Asia/Shanghai","job-server-8800-web.jar",">> /data/logs/8800/spring.log 2>&1"]


docker build -t mobile-app-gateway:v1.0 -f /data/app/jar/Dockerfile2 .
docker run --network=host --name mobile-app-gateway -d mobile-app-gateway:v1.0


docker build -t job-api:v1.0 -f /data/app/jar/Dockerfile1 .
docker run --network=host --name job-api -d job-api:v1.0 

docker build -t job-server:v1.0 -f /data/app/jar/Dockerfile3 .
docker run --network=host --name job-server -d job-server:v1.0 








